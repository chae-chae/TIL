>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

# 포인터 이벤트

포인터 이벤트는 마우스나 펜, 스타일러스, 터치스크린 등등 다양한 포인팅 기기로부터 받은 입력을 다루는 모던한 방법이다.

## 간략한 역사


짧은 개요를 통해 전반적인 그림과 포인터 이벤트의 위치를 이해해 보자.

- 아주 오래전 과거에는, 오직 마우스 이벤트만 존재했다.
  
  그러다가 터치 디바이스, 특히 핸드폰과 타블렛이 널리 보급됐다. 기존의 스크립트가 작동하기 위해서는 마우스 이벤트를 생성해야 했다. 예를 들면, 터치스크린을 태핑하는 것은 `mousedown`을 생성한다. 그래서 터치 디바이스도 웹 페이지에서 잘 작동했다.
  
  하지만 터치 디바이스는 마우스보다 더 다양한 기능이 있었다. 예를 들면, 여러 군데를 한번에 터치하는 것("멀티-터치")이 가능했다. 비록 마우스 이벤트는 그런 멀티-터치를 다뤄야하는 필수 속성이 있지 않았다.

- 그래서 터치-전용 속성을 가진 `touchstart`, `touchend`, `touchmove`와 같은 터치 이벤트가 소개되었다(포인터 이벤트가 훨씬 낫기 때문에 여기서 자세히 다루지는 않는다).
  
  그러나 고유의 기능을 가진 펜처럼 다양한 기기가 있어 여전히 부족했다. 또한 터치와 마우스 이벤트 둘 다에 작동하는 코드를 적는 것은 번거로웠다.

- 이 문제를 해결하기 위해, 새로운 표준 포인터 이벤트가 소개됐다. 그것은 모든 종류의 포인팅 디바이스를 위한 싱글 이벤트 세트를 제공했다.

현재, [Pointer Events Level 2](https://www.w3.org/TR/pointerevents2/) 명세서는 모든 주요 브라우저에서 지원된다. 반면에 최신의 [Pointer Events Level 3](https://w3c.github.io/pointerevents/)는 아직 작업중이고 포인터 이벤트 레벨 2와 대부분 호환된다.

당신이 익스프롤러 10이나 사파리 12 혹은 그 이하의 낡은 브라우저에서 개발하는 게 아니라면, 마우스나 터치 이벤트를 쓰는 것이 더이상 소용이 없다. 포인터 이벤트로 전환할 수 있다.

그러면 당신의 코드는 터치와 마우스 디바이스 둘 다에 잘 작동할 것이다.

그건 그렇고, 포인터 이벤트를 올바르게 사용하고 예기치 못한 문제를 피하기 위해서 몇몇 중요한 특이점이 있다. 이 글에서 그것들을 알아볼 것이다.

## Pointer event types

포인터 이벤트는 마우스 이벤트와 유사한 이름을 가진다:

|Pointer event|Similar mouse event|
|---|---|
|`pointerdown`|`mousedown`|
|`pointerup`|`mouseup`|
|`pointermove`|`mousemove`|
|`pointerover`|`mouseover`|
|`pointerout`|`mouseout`|
|`pointerenter`|`mouseenter`|
|`pointerleave`|`mouseleave`|
|`pointercancel`|-|
|`gotpointercapture`|-|
|`lostpointercapture`|-|

볼 수 있듯, 모든 `mouse<event>`에 있어서, 유사한 역할을 하는 `pointer<event>`이 있다. 또한 `mouse...`와 상응하지 않는 세 개의 부가 포인터 이벤트가 있는데, 좀 있다가 아설명할 것이다.

>**Replacing `mouse<event>` with `pointer<event>` in our code**
>
>우리 코드에서 `mouse<event>` 이벤트를 `pointer<event>`로 대체할 수 있고 마우스로 여전히 잘 작동하기를 기대할 수 있다.
>
>터치 디바이스에 관한 지원 또한 “마법처럼” 향상됐다. 비록, CSS 안의 몇 군데에서 `touch-action: none`을 추가해야 할 수 있다. `pointercancel`에 관한 섹션에서 다룰 것이다.

## Pointer event properties

포인터 이벤트는 `clientX/Y`, `target` 등과 같은 마우스 이벤트와 같은 프로퍼티를 가진다:

- `pointerId` – 이벤트를 발생시키는 포인터의 유니크한 고유 식별자.
    
    브라우저에서 생성됨. 우리로 하여금 스타일러스와 멀티터치가 있는 터치 스크린같은 다중 포인터를 다룰 수 있게 해준다(아래에 예제가 올 것임).
    
- `pointerType` – 포인팅 디바이스 타입. 반드시 다음 중 하나인 문자열이어야 한다: “mouse”, “pen” or “touch”.
    
    이 프로퍼티를 다양한 포인터 타입에 따라 다르게 반응하도록 사용할 수 있다.
    
- `isPrimary` – is `true` for the primary pointer (the first finger in multi-touch).
    

몇몇 포인터 디바이스는 접촉 지점과 압력을 측정한다. 예를 들면 터치스크린에 손가락을 댈 때, 그것을 위한 추가적인 프로퍼티가 있다:

- `width` – 포인터(e.g. 손가락)가 디바이스를 터치하는 영역의 너비. 지원하지 않는 경우, 예를 들면 마우스의 경우 항상 1.
- `height` – 포인터가 디바이스를 터치하는 영역의 높이. 지원하지 않는 경우, 항상 1.
- `pressure` – 범위 0부터 1까지, 포인터 팁의 압력. 압력을 지원하지 않는 기기의 경우, 반드시 `0.5` (누른 경우)나 `0`이다.
- `tangentialPressure` – 평균화된 탄젠트 압력(접선에 가해지는 압력).
- `tiltX`, `tiltY`, `twist` – 펜이 표면에 대하여 어떻게 위치해 있는 지 묘사하는 펜전용 프로퍼티.

이러한 프로퍼티들은 대부분의 디바이스에서 지원하지 않으므로, 거의 쓰이지 않는다. 자세한 것은 필요하다면 [specification](https://w3c.github.io/pointerevents/#pointerevent-interface)에서 알아 보자.

## Multi-touch

마우스 이벤트가 완전히 지원하지 않는 것들 중 하나는 멀티-터치다: 유저가 핸드폰이나 태블릿에서 한번에 여러군데를 터치하거나 특별한 제스쳐를 수행하는 것이다.

포인터 이벤트는 `pointerId`와 `isPrimary` 프로퍼티의 도움으로 멀티-터치를 다루게 해준다.

유저가 한 군데의 터치스크린을 터치하고 다른 손가락을 다른 위치에 두면 무슨 일이 일어나는 지 보자:

1. 첫 번째 손가락이 터치하면:
    - `pointerdown` with `isPrimary=true` and some `pointerId`.
2. 두 번째 손가락과 더 많은 손가락의 경우(첫 번째 손가락이 여전히 터치하고 있다고 가정):
    - `pointerdown` with `isPrimary=false` and a different `pointerId` for every finger.

알아두자: `pointerId`는 전체 디바이스에 할당된게 아니고, 각각 터치하고 있는 손가락에 할당돼 있다. 우리가 다섯 손가락으로 동시에 스크린을 터치하면 5 개의 `pointerdown` 이벤트를 얻는다. 그것들 각각에 대응되는 좌표와 다른 `pointerId`를 가진다.

첫 번째 손가락과 연관된 이벤트는 항상 `isPrimary=true`를 가진다.

우리는 다중 터치하고 있는 손가락을 그들의 `pointerId`를 써서 추적할 수 있다. 유저가 움직이다가 손가락을 제거할 때, 우리는 `pointerdown`에서 얻었던 것처럼 같은 `pointerId`를 가진 `pointermove`와 `pointerup` 이벤트를 얻는다.

알아두자: `pointerId/isPrimary`의 차이점을 보려면 반드시 폰이나 태블릿같은 터치스크린 기기를 사용해야 한다. 마우스같은 싱글-터치 디바이스의 경우, 모든 포인터 이벤트에 관해 `isPrimary=true`를 가진 같은 `pointerId`가 있을 것이다.

## Event: pointercancel

`pointercancel` 이벤트는 진행 중인 포인터 상호작용이 있을 때 시작되고, 더 이상 포인터 이벤트가 발생하지 않도록 그것이 중단되도록 하는 무언가가 발생한다.

그 무언가의 원인에는:

- 포인터 디바이스 하드웨어가 물리적으로 사용 불가능.
- 디바이스 방향이 변함(태블릿이 회전함).
- 브라우저가 마우스 제스쳐나 zoom-and-pan 액션 등을 고려하여 자기가 직접 상호작용을 다루기로 함.

실용적인 예제에서 `pointercancel`가 어떻게 우리에게 영향을 주는 지 설명하겠다.

우리가 [드래그 앤 드롭과 마우스 이벤트](https://ko.javascript.info/mouse-drag-and-drop)의 시작부분에서 한 것처럼 공을 드래그앤드롭하는 것을 구현한다고 해보자.

여기 유저 액션과 상응하는 이벤트의 흐름이다:

1. 유저가 이미지를 누르고 드래그하기 시작함
    - `pointerdown` 이벤트 발생
2. 이후 포인터를 움직이기 시작(즉 이미지를 드래그)
    - `pointermove` 발생, 여러번 발생할 것임
3. 그러고 나서 놀라운 일이 발생한다! 브라우저는 이미지를 지원하는 네이티브 드래그앤드롭을 가진다. 이것은 드래그앤드롭 과정에 침투하여 제어를 가져간다. 그러므로  `pointercancel` 이벤트를 생성한다.
    - 브라우저는 이제 그들 스스로 이미지의 드래그앤드롭을 다룬다. 유저는 브라우저밖으로 볼 이미지를 드래그하여 그들의 메일 프로그램이나 파일 매니저 안으로 드래그할 수도 있다.
    - 우리에게 `pointermove` 이벤트가 더이상 없다.

그러므로 문제는 브라우저가 상호작용을 “하이재킹”한다는 것이다: `pointercancel`가 “drag-and-drop” 과정의 시작에 발생하고 더이상 `pointermove` 이벤트가 발생하지 않는다.

