# CORS

`fetch`로 요청을 보내게 될 사이트가 현재 접속 사이트와 다르다면 요청이 실패할 수 있다.

직접 `http://example.com`라는 사이트에 요청을 보내보자.

```js
try {
  await fetch('http://example.com');
} catch(err) {
  alert(err); // TypeError: Failed to fetch
}
```

요청이 실패한 것을 확인할 수 있다.

왜 요청이 실패하는지 알기 위해선 도메인·프로토콜·포트 세 가지에 의해 결정되는 _오리진(origin)_ 이라는 핵심 개념을 알아야 한다.

도메인이나 서브도메인, 프로토콜, 포트가 다른 곳에 요청을 보내는 것을 Cross-Origin Request(크로스 오리진 요청)라고 한다. 크로스 오리진 요청을 보내려면 리모트 오리진에서 전송받은 특별한 헤더가 필요하다.

이러한 정책을 'CORS(Cross-Origin Resource Sharing, 크로스 오리진 리소스 공유)'라고 부른다.

## 왜 CORS가 필요한가에 대한 짧은 역사

CORS는 악의를 가진 해커로부터 인터넷을 보호하기 위해 만들어졌다.

지금부턴 어떤 사건 때문에 CORS가 만들어졌는지를 짧은 역사를 통해 살펴보겠다.

**과거 수 년 동안, 한 사이트의 스크립트에서 다른 사이트에 있는 콘텐츠에 접근할 수 없다는 제약이 있었다.**

이런 간단하지만 강력한 규칙은 인터넷 보안을 위한 근간이었다. 보안 규칙 덕분에 해커가 만든 웹 사이트 `hacker.com`에서 `gmail.com`에 있는 메일 박스에 접근할 수 없던 것이다. 사람들은 이런 제약 덕분에 안전하게 인터넷을 사용할 수 있었다.

그런데 이 당시의 자바스크립트는 네트워크 요청을 보낼 수 있을 만한 메서드를 지원하지 않았다. 자바스크립트는 웹 페이지를 꾸미기 위한 토이 랭귀지 수준이었다.

하지만 많은 웹 개발자들이 강력한 기능을 원하기 시작하면서 위와 같은 제약을 피해 다른 웹 사이트에 요청을 보내기 위한 트릭들을 만들기 시작했다.

### 폼 사용하기

트릭 중 하나로 `<form>`이 사용되곤 했다. 개발자들은 `<form>`안에 `<iframe>`을 넣어 `<form>`을 전송했다. 이렇게 해 현재 사이트에 남아있으면서 네트워크 요청을 보냈었다. 예시를 살펴보자.