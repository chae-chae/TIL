# XMLHttpRequest

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

`XMLHttpRequest`는 자바스크립트에서 HTTP 리퀘스트를 만들 수 있게 해주는 빌트-인 브라우저 객체이다.

“XML”이라는 단어가 이름에 있지만, XML 포맷뿐만 아니라 무슨 데이터든지 다룰 수 있다. 우리는 파일을 업로드/다운로드하거나, 과정을 추적하는 등 그 밖의 많은 일을 할 수 있다.

지금은 `XMLHttpRequest` 대신에 쓰이는 `fetch`라는 좀 더 현대적인 메서드가 있다.

모던 웹 개발에서 `XMLHttpRequest`는 세가지 이유로 쓰인다:

1. 역사적인 이유: `XMLHttpRequest`로 이미 쓰인 스크립트를 지원해야 함.
2. 구식 브라우저를 지원해야 하는데 폴리필은 원하지 않음(예: 스크립트를 짧게 유지하기 위해).
3. `fetch`가 아직 할 수 없는 것이 필요함. 예: 업로드 과정을 추적하기.

익숙하게 들리는가? 만약 그렇다면 `XMLHttpRequest`를 계속 보자. 아니라면 [fetch](https://ko.javascript.info/fetch)로 가자.

## The basics

XMLHttpRequest는 두 작동 모드가 있다: 동기와 비동기다.

비동기부터 보자. 이게 주로 쓰인다.

리퀘스트를 처리하기 위해, 우리는 세 단계를 거친다:

1. `XMLHttpRequest` 생성:
   ```js
	   let xhr = new XMLHttpRequest();
	```
	
	생성자는 인자가 없다.

2. 초기화. 보통 `new XMLHttpRequest` 직후에 일어남:
   ```js
	   xhr.open(method, URL, [async, user, password])
	```
	
	이 방법은 리퀘스트의 메인 파라미터를 지정한다:
	- `method` – HTTP-메서드. 보통 `"GET"`이나 `"POST"`.
	- `URL` – 리퀘스트로의 URL. 문자열이고 [URL](https://ko.javascript.info/url) 객체가 될 수도 있음.
	- `async` – 만약 명시적으로 `false`로 설정하면, 리퀘스트는 동기가 됨. 이후 다룰것임.
	- `user`, `password` – 기본 HTTP 인증(필요하다면)을 위한 로그인과 패스워드.
	
	`open` 호출은 그 이름과는 다르게 연결을 열지 않는다는 것을 알아두자. `open` 호출은 리퀘스트를 설정만 하고, 네트워크 활동은 오직 `send` 호출로만 시작한다.

3. 내보내기.
   ```js
	   xhr.send([body])
	```
	
	이 메서드는 연결을 열고 서버로 리퀘스트를 보낸다. 선택사항인 `body` 파라미터는 리퀘스트 바디를 포함한다.
	
	`GET`과 같은 몇몇 리퀘스트 메서드는 바디를 가지고 있지 않다. 그리고 `POST`같은 그중 몇몇은 서버로 데이터를 보내기 위해 `body`를 쓴다. 이후 예시를 볼 것이다.

4. 리스폰스를 위해 `xhr` 이벤트를 들음:
   
   이 세개의 이벤트가 가장 널리 쓰인다:
   - `load` – 리퀘스트가 완료됐을 때(HTTP status가 400이나 500이어도), 그리고 리스폰스가 완전히 다운로드됐을 때.
   - `error` – 리퀘스트가 만들어지지 못했을 때. 예: 네트워크 끊김이나 잘못된 URL로 인해.
   - `progress` – 리스폰스가 다운로드되고 있는 동안 주기적으로 트리거되어, 얼마나 다운로드되었는 지 알림.
	```js
    xhr.onload = function() {
		alert(`Loaded: ${xhr.status} ${xhr.response}`);
	};
	
	xhr.onerror = function() { // only triggers if the request couldn't be made at all
		alert(`Network Error`);
	};
	
	xhr.onprogress = function(event) { // triggers periodically
		// event.loaded - how many bytes downloaded
		// event.lengthComputable = true if the server sent Content-Length header
		// event.total - total number of bytes (if lengthComputable)
		alert(`Received ${event.loaded} of ${event.total}`);
	};
	```

여기 전체 예제가 있다. 아래의 코드는 서버에서 `/article/xmlhttprequest/example/load`에서 URL을 로드하고 과정을 출력한다:

```js
// 1. Create a new XMLHttpRequest object
let xhr = new XMLHttpRequest();

// 2. Configure it: GET-request for the URL /article/.../load
xhr.open('GET', '/article/xmlhttprequest/example/load');

// 3. Send the request over the network
xhr.send();

// 4. This will be called after the response is received
xhr.onload = function() {
  if (xhr.status != 200) { // analyze HTTP status of the response
    alert(`Error ${xhr.status}: ${xhr.statusText}`); // e.g. 404: Not Found
  } else { // show the result
    alert(`Done, got ${xhr.response.length} bytes`); // response is the server
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Received ${event.loaded} of ${event.total} bytes`);
  } else {
    alert(`Received ${event.loaded} bytes`); // no Content-Length
  }

};

xhr.onerror = function() {
  alert("Request failed");
};
```

서버가 응답하면, 우리는 아래의 `xhr` 프로퍼티로 결과를 받을 수 있다:

**`status`**

HTTP status 코드(숫자): `200`, `404`, `403` 등등. non-HTTP 실패의 경우 `0`도 가능.

**`statusText`**

HTTP status 메시지(문자열): 보통 `200`에는 `OK`, `404`에는 `Not Found`, `403`에는 `Forbidden` 등등.

**`response` (구식 스크립트는 `responseText`를 사용할 수도 있음)**

서버 리스폰스 바디.

해당 프로퍼티를 사용하여 타임아웃을 지정할 수도 있다:

```js
xhr.timeout = 10000; // timeout in ms, 10 seconds
```

리퀘스트가 주어진 시간 내 성공하지 못하면, 취소되고 `timeout` 이벤트가 트리거된다.

>**URL search parameters**
>
>URL에 `?name=value`같은 파라미터를 추가하고 적절한 인코딩을 보장하려면, 우리는 [URL](https://ko.javascript.info/url) 객체를 쓸 수 있다.
>
>```js
>let url = new URL('https://google.com/search');
>url.searchParams.set('q', 'test me!');
>
>// the parameter 'q' is encoded
>xhr.open('GET', url); // https://google.com/search?q=test+me%21
>```

