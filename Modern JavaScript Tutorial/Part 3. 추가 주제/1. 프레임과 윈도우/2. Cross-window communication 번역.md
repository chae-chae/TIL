# Cross-window communication

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

“동일 출처” (동일 사이트) 정책은 창과 프레임 서로의 접근을 제한한다.

유저가 두 페이지를 열었을 때: 하나는 `john-smith.com`, 다른 하나는 `gmail.com`이면, `john-smith.com`에서 온 스크립트가 `gmail.com`에서 온 메일을 읽는 걸 원하지 않는다. 그러므로, “동일 출처” 정책의 목적은 정보 강탈으로부터 유저를 보호하는 것이다.

## 동일 출처

만약 같은 프로토콜, 도메인, 포트를 가질 때, 두 URL은 “동일 출처”라고 부른다.

이 URL들은 모두 동일 출처를 공유한다:

- `http://site.com`
- `http://site.com/`
- `http://site.com/my/page.html`

이것들은 아니다:

- `http://**www.**site.com` (다른 도메인: `www.` 때문)
- `http://**site.org**` (다른 도메인: `.org` 때문)
- `**https://**site.com` (다른 프로토콜: `https`)
- `http://site.com:**8080**` (다른 포트: `8080`)

“동일 출처” 정책의 의미:

- 만약 우리가 다른 창에 관한 레퍼런스를 갖고 있다면, 예를 들어 `window.open`에 의해 만들어진 팝업이나 `<iframe>`안의 창같은 경우, 그 창이 동일 출처에서 왔다면, 우리는 그 창에 모든 접근이 가능하다.
- 그렇지 않고 만약 다른 출처에서 왔다면, 우리는 그 창의 내용물에 접근할 수 없다: 변수, 문서, 무엇이든 말이다. 유일한 예외는 `location`이다: 이건 바꿀 수 있다(유저를 리다이렉팅하기 위해). 하지만 우리가 위치를 *읽을* 수는 없다(그래서 유저가 지금 어디에 있는지, 정보가 새지 않는다).

### In action: iframe

`<iframe>` 태그는 그 자신만의 분리된 `document`와 `window` 객체로 분리된 임베디드 창을 호스트한다.

우리는 프로퍼티를 사용해 그것에 접근할 수 있다:

- `<iframe>`안의 창을 얻기 위한 `iframe.contentWindow`. 
- `<iframe>`안의 문서를 얻기 위한 `iframe.contentDocument`,  `iframe.contentWindow.document`를 짧게 줄인 것이다.

임베디드 창 안의 무언가에 접근할 때, 브라우저는 iframe이 동일 출처를 갖는 지 확인한다. 만약 그렇지 않으면 접근이 거부된다(`location`에 쓰기를 하려는 경우는 예외다. 이건 여전히 허용된다).

예를 들어, 다른 출처에서 온 `<iframe>`에 읽기와 쓰기를 시도해보자.

```html
<iframe src="https://example.com" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // we can get the reference to the inner window
    let iframeWindow = iframe.contentWindow; // OK
    try {
      // ...but not to the document inside it
      let doc = iframe.contentDocument; // ERROR
    } catch(e) {
      alert(e); // Security Error (another origin)
    }

    // also we can't READ the URL of the page in iframe
    try {
      // Can't read URL from the Location object
      let href = iframe.contentWindow.location.href; // ERROR
    } catch(e) {
      alert(e); // Security Error
    }

    // ...we can WRITE into location (and thus load something else into the iframe)!
    iframe.contentWindow.location = '/'; // OK

    iframe.onload = null; // clear the handler, not to run it after the location change
  };
</script>
```

위의 코드는 아래 예외를 제외하고는 모두 에러를 보인다:

- `iframe.contentWindow` 안의 창에 관한 레퍼런스를 얻는 것 – 이건 허용됨.
- `location`에 쓰기.

반면에, 만약 `<iframe>`이 동일 출처를 가지면, 우리는 무엇이든 할 수 있다:

```html
<!-- iframe from the same site -->
<iframe src="/" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // just do anything
    iframe.contentDocument.body.prepend("Hello, world!");
  };
</script>
```

>**`iframe.onload` vs `iframe.contentWindow.onload`**
>
>`iframe.onload` 이벤트(`<iframe>`태그에서)는 본질적으로 `iframe.contentWindow.onload`와 같다(임베디드 창 객체에서). 임베디드 창이 모든 리소스와 함께 완전히 로드되었을 때 트리거된다.
>
>...하지만 다른 출처에서 온 iframe의 `iframe.contentWindow.onload`에는 접근할 수 없다. 그러므로 `iframe.onload`를 쓴다.

