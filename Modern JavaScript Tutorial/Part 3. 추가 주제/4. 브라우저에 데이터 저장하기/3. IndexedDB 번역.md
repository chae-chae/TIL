# IndexedDB

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

IndexedDB는 `localStorage`보다 훨씬 강력한, 브라우저 빌트-인 데이터베이스다.

- 다중 키 타입의 키를 써서 거의 모든 종류의 값을 저장한다.
- 신뢰성을 위한 트랜잭션을 지원한다.
- 키 범위 쿼리, 인덱스를 지원한다.
- `localStorage`보다 훨씬 큰 볼륨의 데이터를 저장할 수 있다.

그 힘은 보통 전통적인 클라이언트-서버 앱에는 과분하다. IndexedDB는 ServiceWorkers와 다른 기술과 결합되기 위한 오프라인 앱을 위한 것이다.

IndexedDB의 네이티브 인터페이스는 명세서 [https://www.w3.org/TR/IndexedDB](https://www.w3.org/TR/IndexedDB)에 설명되어 있으며, 이벤트 베이스다.

또한 [https://github.com/jakearchibald/idb](https://github.com/jakearchibald/idb)같은 프로미스-베이스 래퍼의 도움을 받아 `async/await`을 쓸 수도 있다. 이건 꽤나 편리하지만 래퍼가 완벽한 것은 아니기에 모든 경우의 이벤트를 대체할 수는 없다. 그러니 우리는 이벤트로 시작할 것이고 이후에 IndexedDb를 이해하고 나면 래퍼를 쓸 것이다.

## Open database

IndexedDB로 작업을 시작하기 위해, 먼저 데이터 베이스를 `open` (연결) 해야한다.

문법:

```js
let openRequest = indexedDB.open(name, version);
```

- `name` – 문자열, 데이터베이스 이름.
- `version` – 양수 버전, by default `1` (explained below).

다른 이름을 가진 많은 데이터베이스를 가질 수 있지만, 그것들 전부 현재 출처(domain/protocol/port) 안에 존재한다. 다른 웹사이트들은 서로의 데이터베이스에 접근할 수 없다.

호출은 `openRequest` 객체를 반환하고 그것에 있는 이벤트를 들어야 한다:

- `success`: 데이터베이스가 준비됨, `openRequest.result`안에 우리가 이후 이어질 더 많은 호출을 위해 써야하는 “데이터베이스 객체”가 있다.
- `error`: 오프닝 실패.
- `upgradeneeded`: 데이터베이스가 준비됨, 하지만 버전이 낡았음(see below).

**IndexedDB는 서버사이드 데이터베이스에 없는 “schema versioning(스키마 버전 관리)”의 빌트-인 메커니즘을 가진다.**

서버사이드 데이터베이스와는 다르게, IndexedDB는 클라이언트사이드로, 데이터가 브라우저에 저장된다. 그래서 우리 개발자들은 그것에 풀타임 접근권한이 없다. 그래서 우리가 새로운 버전의 앱을 퍼블리싱할 때, 유저가 우리 웹페이지를 방문하면 우리는 데이터베이스를 업데이트 해야할 수 있다.

만약 로컬 데이터베이스 버전이 `open`에 명시된 것보다 낮다면, 특별한 이벤트 `upgradeneeded`가 트리거되고 우리는 버전을 비교해 필요하다면 데이터 구조를 업그레이드할 수 있다.

`upgradeneeded` 이벤트는 데이터베이스가 아직 존재하지 않을 때(엄밀히 따지자면, 버전 `0`)에도 트리거한다. 그래서 초기화를 수행할 수 있다.

우리 앱의 첫 버전을 출시했다고 해보자.

우리는 버전 `1`로 데이터베이스를 열 수 있고 `upgradeneeded` 핸들러에서 이렇게 초기화를 수행할 수 있다:

```js
let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {
  // triggers if the client had no database
  // ...perform initialization...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // continue working with database using db object
};
```

이후, 우리는 두번째 버전을 출시한다.

우리는 버전 `2`로 열어서 이렇게 업그레이드를 수행할 수 있다:

```js
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function(event) {
  // the existing database version is less than 2 (or it doesn't exist)
  let db = openRequest.result;
  switch(event.oldVersion) { // existing db version
    case 0:
      // version 0 means that the client had no database
      // perform initialization
    case 1:
      // client had version 1
      // update
  }
};
```

알아두자: 우리의 현재 버전은 `2`이기 때문에, `onupgradeneeded` 핸들러는 처음으로 접근해서 데이터 베이스가 없는 유저에게 적합하고, 또한 업그레이드를 위한 버전 `1`을 위해 버전 `0`의 코드 브랜치를 가진다.

그리고 나서 오직 `onupgradeneeded` 핸들러가 에러없이 끝날 때만 `openRequest.onsuccess`가 트리거하고 데이터베이스는 성공적으로 열렸다고 간주된다.

데이터베이스 삭제를 위해서는:

```js
let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror tracks the result
```

>**데이터베이스의 오래된 버전은 열 수 없다.**
>
>만약 현재 유저 데이터베이스가 `open` 호출에 있는 것보다 높은 버전이라면, 예를 들어 현존 DB 버전이 `3`이고 우리는 `open(...2)`를 하려고 하면, 에러가 발생하고 `openRequest.onerror`가 트리거된다.
>
>이런 일은 드물지만, 방문자가 예를 들면 프록시 캐시로부터 낡은 자바스크립트 코드를 로드하려고 할 때, 발생할 수 있다. 그래서 코드는 오래됐지만 그 데이터베이스는 새 것이다.
>
>에러로부터 보호하려면, `db.version`을 확인하고 페이지 새로고침을 제안해야 한다. 이런 문제를 절대 겪지 않도록 오래된 코드를 로딩하는 것을 피하기 위해 적절한 HTTP 캐싱 헤더를 쓰자.

### Parallel update problem

versioning에 관해 얘기한 김에, 연관된 작은 문제를 보자.

자, 이렇다:

1. 방문자는 데이터베이스 버전 `1`로 우리 사이트를 브라우저 탭에서 연다.
2. 그 후 우리는 업데이트를 해서 코드가 더 새 것이다.
3. 그리고 나서 같은 방문자가 우리 사이트를 다른 탭에서 연다.

DB 버전 `1`에 연결된 탭 하나가 있다, 두번째 탭은 그것을 두번째 탭의 `upgradeneeded` 핸들러 안에서 버전 `2`로 업그레이드하려는 시도를 한다.

문제는 두 탭이 같은 사이트, 같은 출처이기 때문에 데이터베이스가 그 사이에 공유되고 있다는 것이다. 그리고 데이터베이스는 버전 `1`과 `2` 중 하나만 될 수 있다. 버전 `2`로 업데이트를 수행하려면, 첫 번째 탭을 포함한 버전 1로의 모든 연결이 반드시 닫혀야 한다.

그걸 정리하기 위해서, `versionchange` 이벤트가 “outdated(낡은)” 데이터베이스 객체에서 트리거한다. 우리는 그 이벤트를 듣고 낡은 데이터베이스 연결을 끊어야 한다(그리고 업데이트된 코드를 불러오기 위해 페이지 새로고침을 제안해야 할 것이다).

만약 우리가 `versionchange` 이벤트를 듣지 않고 오래된 연결을 닫지 않으면, 두번째의 새 연결이 만들어지지 않을 것이다. `openRequest` 객체는 `success` 대신에 `blocked` 이벤트를 발생시킬 것이다. 그러므로 두번째 탭은 작동하지 않을 것이다.

여기 병렬 업그레이드를 올바르게 다루기 위한 코드다.

이 코드는 오래된 연결을 닫는`onversionchange` 핸들러를 데이터베이스가 열린 뒤에 설치한다.

```js
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  db.onversionchange = function() {
    db.close();
    alert("Database is outdated, please reload the page.")
  };

  // ...the db is ready, use it...
};

openRequest.onblocked = function() {
  // this event shouldn't trigger if we handle onversionchange correctly

  // it means that there's another open connection to same database
  // and it wasn't closed after db.onversionchange triggered for them
};
```

여기서 우리는 두 가지 일을 한다:

1. 병렬 업데이트 시도에 관해 알리기 위해서, 성공적인 오프닝 이후 `db.onversionchange` 리스너를 추가한다.
2. 오래된 연결이 닫히지 않았을 때를 다루기 위해 `openRequest.onblocked` 리스너를 추가한다. 이것은 우리가 `db.onversionchange`안에서 연결을 닫으면 발생하지 않는다.

다른 변형도 있다. 예를 들어, `db.onversionchange`에서 작업을 정상적으로 종료하고, 연결이 닫히기 전에 방문자에게 데이터를 저장하라는 메시지를 띄울 수 있다. 새로운 업데이트 연결은 `db.onversionchange`가 완료되지 않은 상태에서 즉시 막힐 것이고 새 탭의 방문자에게 업데이트를 위해 다른 탭을 닫으라고 요청할 수 있다.

이러한 업데이트 충돌은 드물게 발생하지만, 스크립트가 조용히 죽어가면서 유저를 놀래키지 않도록, `onblocked` 핸들러같은 것으로 다루는 방법을 알아야 한다.

## Object store

IndexedDB 안에 뭔가를 저장하려면, *object store*이 필요하다.

객체 저장소(object store)는 IndexedDB의 핵심 개념이다. 다른 데이터베이스에서는 “테이블”이나 “컬렉션”으로 대응된다. 데이터가 저장되는 곳이다. 데이터베이스는 다중 저장소를 가질 수 있다: 하나는 유저를 위한 것, 또 다른 하나는 물건을 위한 것 등등.

“object store”라고 이름붙였지만, 원시형도 저장할 수 있다.

**우리는 복잡한 객체를 포함해 거의 어떤 값이든 저장할수 있다.**

IndexedDB는 객체를 복제하고 저장하기 위해 [standard serialization algorithm](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage)를 사용한다.이것은 마치 `JSON.stringify`같지만, 더 강력하고 훨씬 많은 데이터 타입을 저장하는 게 가능하다.

저장할 수 없는 객체의 예: 순환 참조를 가진 객체. 그런 객체는 연속적이지 않다. `JSON.stringify` 또한 그런 객체에 실패한다.

**저장된 모든 값에 대한 유일한(unique) `key`가 반드시 있어야 한다.**

키는 반드시 이러한 타입 중 하나여야 한다 – number, date, string, binary, 또는 array. 이것은 유니크한 구별자로, 우리가 키를 통해 값을 search/remove/update 할 수 있다.

<img src="https://ko.javascript.info/article/indexeddb/indexeddb-structure.svg" alt="" width="484" height="267">

우리가 곧 볼 것이지만, `localStorage`와 유사하게 값을 저장소에 추가할 때 키를 제공할 수 있다. 하지만 객체를 저장할 때, IndexedDB는 훨씬 더 편리한 키로써 객체 프로퍼티를 설정하는 걸 허용한다. 혹은 우리는 키를 자동생성할 수도 있다.

하지만 우리는 객체 저장소를 먼저 생성해야 한다.

객체 저장소를 생성하기 위한 문법:

```js
db.createObjectStore(name[, keyOptions]);
```

작업은 동기적이고 `await`가 필요하지 않다는 걸 알아두자.

- `name`은 저장소 이름. 예: 책을 위한 `"books"`,
- `keyOptions`는 두 프로퍼티 중 하나를 가진 옵션 객체다:
    - `keyPath` – IndexedDB가 키로써 쓸 객체 프로퍼티로의 경로. 예: `id`.
    - `autoIncrement` – 만약 `true`이면, 새로 저장된 객체를 위한 키가 부단히 증가하는 숫자로 자동으로 생성된다.

만약 `keyOptions`를 제공하지 않으면, 이후 객체를 저장할 때 명시적으로 키를 제공해야 한다.

예를 들어, 이 객체 저장소는 키로써 `id` 프로퍼티를 사용한다:

```js
db.createObjectStore('books', {keyPath: 'id'});
```

**객체 저장소는 오직 `upgradeneeded` 핸들러내에서 DB 버전을 업데이트하는 중에만 생성/수정될 수 있다.**

그것은 기술적인 제한이다. 핸들러 바깥에서 데이터를 추가/제거/업데이트하는 것은 가능하지만, 객체 저장소는 오직 버전 업데이트 도중에만 생성.제거/변경될 수 있다.

데이터베이스 버전 업그레이드를 수행하기 위해, 두개의 주요 접근법이 있다:

1. 우리는 버전마다 업그레이드 함수를 구현할 수 있다: 1부터 2, 2부터 3, 3부터 4 등. 이후 `upgradeneeded`에서 버전을 비교할 수 있고(예: 낡은 2버전, 현재 4버전) 모든 중간 버전에 대하여 단계별로 버전별 업그레이드를 실행한다(2 to 3, then 3 to 4).
2. 혹은 그저 데이터베이스를 조사할 수 있다: `db.objectStoreNames`로 현존하는 객체 저장소의 목록을 얻는다. 그 객체는 존재여부를 확인하는 `contains(name)`메서드를 제공하는 [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist)다. 그리고 무엇이 존재하고 존재하지 않는지에 따라 업데이트를 수행할 수 있다.

작은 데이터베이스의 경우 두 번째 변수가 더 간단할 수 있다.

여기 두 번째 접근법의 데모다:

```js
let openRequest = indexedDB.open("db", 2);

// create/upgrade the database without version checks
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // if there's no "books" store
    db.createObjectStore('books', {keyPath: 'id'}); // create it
  }
};
```

객체 저장소를 삭제하려면:

```js
db.deleteObjectStore('books')
```

## Transactions

용어 “transaction”은 generic(포괄적)이라 많은 종류의 데이터베이스에서 사용된다.

트랜잭션은 모두 성공하거나 모두 실패, 둘 중 하나인 그룹 작업이다.

예시로, 한 사람이 뭔가를 구매할 때, 우리는 이런 것을 해야 한다:

1. 그의 계좌로부터 돈을 뺀다.
2. 그의 인벤토리에 아이템을 추가한다.

우리가 첫 번째 작업만 완료하고 뭔가가 잘못되면(예: 정전이 발생해 2번째 수행이 실패)  꽤나 곤란할 것이다. 둘 다 성공하거나(구입 완료), 둘 다 실패하거나(적어도 그 사람이 돈은 유지해서 다시 시도할 수 있도록) 해야한다.

트랜잭션은 그것을 보장할 수 있다.

**모든 데이터 작업은 반드시 IndexedDB의 트랜잭션 안에서 이뤄져야 한다.**

트랜잭션을 시작하기 위해:

```js
db.transaction(store[, type]);
```

- `store`는 트랜잭션이 접근할 저장소 이름.예: `"books"`. 만약 여러 개의 저장소에 접근하려면 저장소 이름의 배열이 될 수 있다.
- `type` – 트랜잭션 타입, 이들 중 하나:
    - `readonly` – 읽기 전용, 기본.
    - `readwrite` – 데이터 읽기 쓰기 전용, 객체 저장소를 생성/제거/변경할 수 없음.

`versionchange` 트랜잭션 타입도 있다: 그런 트랜잭션은 무엇이든 할 수 있지만, 수동으로 생성할 수는 없다. IndexedDB는 데이터베이스를 열 때, `updateneeded`핸들러를 위해 자동으로 `versionchange` 트랜잭션을 생성한다. 이것이 IndexedDB가 데이터베이스 구조를 업데이트하고 객체 저장소를 생성/제거할 수 있는 단 하나의 장소인 이유다.

>**왜 다른 종류의 트랜잭션이 존재할까?**
>
>퍼포먼스는 트랜잭션이 `readonly`와 `readwrite` 중 하나로 구분되어야 하는 이유이다.
>
>많은 `readonly` 트랜잭션은 같은 저장소로 동시에 접근할 수 있지만, `readwrite` 트랜잭션은 불가능하다. `readwrite` 트랜잭션은 저장소에 쓰기작업하는 것을 “잠근다”. 다음 트랜잭션은 동일한 저장소에 접근하기 전에 이전의 것이 완료되기까지 반드시 기다려야 한다.

트랜잭션이 생성되고 난 후, 저장소에 아이템을 이렇게 추가할 수 있다:

```js
let transaction = db.transaction("books", "readwrite"); // (1)

// get an object store to operate on it
let books = transaction.objectStore("books"); // (2)

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
  console.log("Book added to the store", request.result);
};

request.onerror = function() {
  console.log("Error", request.error);
};
```

기본적으로 4 단계가 존재한다:ㅣ

1. `(1)`에서, 모든 저장소가 접근할 것이라고 언급하는 트랜잭션을 생성함.
2. `(2)`에서, `transaction.objectStore(name)`을 사용해 저장소 객체를 얻음.
3. `(3)`에서, 객체 저장소로의 요청 `books.add(book)`을 수행함.
4. …요청 성공/에러를 `(4)`에서 다루고, 필요하다면 다른 요청을 만들 수 있음.

객체 저장소는 값을 저장하기 위한 두 메서드를 지원한다:

- **put(value, [key])** 저장소에 `value`를 추가한다. 객체 저장소가 `keyPath`나 `autoIncrement` 옵션이 없을 때만 `key`가 제공된다. 만약 동일한 키로 값이 이미 존재하면, 대체된다.
    
- **add(value, [key])** `put`과 마찬가지지만, 같은 키로 값이 이미 존재하면, 요청이 실패하고 `"ConstraintError"`라는 이름을 가진 에러가 생성된다.
    

데이터베이스를 여는 것과 유사하게, 요청을 전송할 수 있다: `books.add(book)`, 그리고 `success/error` 이벤트를 기다린다.

- `add`를 위한 `request.result`는 새로운 객체의 키다.
- 에러는 `request.error`안에 있다(만약 있다면).

## Transactions’ autocommit

위의 예시에서 우리는 트랜잭션을 시작했고 `add` 요청을 만들었다. 하지만 이전에 언급했듯, 트랜잭션은 반드시 모두 성공하거나 모두 실패해야 하는 여러 개의 연관된 요청을 가질 수 있다. 더이상 요청이 오지 않는데 어떻게 우리는 트랜잭션이 끝났다고 표시할 수 있을까?

짧은 답변으로: 할 수 없다.

명세서의 다음 버전 3.0에서, 트랜잭션을 수동으로 완료하는 방법이 있을 수 있지만, 현재 2.0에는 없다.

**모든 트랜잭션 요청이 끝났고 [microtasks queue](https://ko.javascript.info/microtask-queue)이 비어있을 때, 자동으로 커밋된다.**

대개, 모든 그것의 요청이 완료되고 현재 코드가 끝날 때, 트랜잭션이 커밋된다고 추정한다.

그러므로 위의 예시에서는 트랜잭션을 끝내기 위해 특별한 호출이 필요하지 않다.

트랜잭션 자동 커밋 원칙은 중요한 부작용을 가진다. 우리는 `fetch`와 트랜잭션의 중간에 있는 `setTimeout` 같은 비동기 작업을 삽입할 수 없다. IndexedDB는 이러한 것들이 완료되기 전까지 트랜잭션을 기다리게 하지 않을 것이다.

아래 코드에서, `(*)`줄에 있는 `request2`는 실패한다. 트랜잭션이 이미 커밋되었고, 그 안에 다른 요청을 만들 수 없기 때문이다:

```js
let request1 = books.add(book);

request1.onsuccess = function() {
  fetch('/').then(response => {
    let request2 = books.add(anotherBook); // (*)
    request2.onerror = function() {
      console.log(request2.error.name); // TransactionInactiveError
    };
  });
};
```

이것은 `fetch`가 비동기 작업, macrotask이기 때문이다. 트랜잭션은 브라우저가 매크로태스크를 시작하기 전에 닫힌다.

IndexedDB 명세서의 저자들은 트랜잭션은 short-lived(생애 주기가 짧다)여야 한다고 믿는다. 대부분 퍼포먼스 때문이다.

눈에 띄게, `readwrite` 트랜잭션은 쓰기를 위해 저장소를 “잠근다”. 그래서 만약 어플리케이션의 한 부분이 `books` 객체 저장소에 `readwrite`를 시작했다면, 같은 일을 하고 싶은 다른 부분은 기다려야 한다: 새로운 트랜잭션은 첫번째 것이 완료될 때까지 “매달린다“. 만약 트랜잭션이 오랜 시간 걸린다면 이상한 딜레이로 이끌 수 있다.

그러면 어떻게 해야할까?

위의 예시에서 우리는 새로운 요청 `(*)` 바로 직전에 새로운 `db.transaction`을 만들 수 있었다.

하지만 만약 우리가 작업을 IndexedDB 트랜잭션과 “다른” 비동기 작업을 분리하기 위해 하나의 트랜잭션에 한꺼번에 둔다면 더 나을 것이다.

먼저, `fetch`를 만들고, 필요하다면 데이터를 준비한 뒤, 트랜잭션을 생성하고 모든 데이터베이스 요청을 수행한 후에 잘 작동할 것이다.

성공적인 완료의 순간을 감지하기 위해, `transaction.oncomplete` 이벤트를 들을 수 있다:

```js
let transaction = db.transaction("books", "readwrite");

// ...perform operations...

transaction.oncomplete = function() {
  console.log("Transaction is complete");
};
```

오직 `complete`만이 트랜잭션이 전체로써 저장되었다는 것을 보장한다. 개별적인 요청은 성공할 수 있지만, 마지막 쓰기 작업은 잘못될 수 있다(예: I/O error or something).

수동으로 트랜잭션을 취소하기 위해서는 이걸 호출하자:

```js
transaction.abort();
```

이것은 요청에 의해 만들어진 모든 수정사항을 취소하고 `transaction.onabort` 이벤트를 트리거한다.