# IndexedDB

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

IndexedDB는 `localStorage`보다 훨씬 강력한, 브라우저 빌트-인 데이터베이스다.

- 다중 키 타입의 키를 써서 거의 모든 종류의 값을 저장한다.
- 신뢰성을 위한 트랜잭션을 지원한다.
- 키 범위 쿼리, 인덱스를 지원한다.
- `localStorage`보다 훨씬 큰 볼륨의 데이터를 저장할 수 있다.

그 힘은 보통 전통적인 클라이언트-서버 앱에는 과분하다. IndexedDB는 ServiceWorkers와 다른 기술과 결합되기 위한 오프라인 앱을 위한 것이다.

IndexedDB의 네이티브 인터페이스는 명세서 [https://www.w3.org/TR/IndexedDB](https://www.w3.org/TR/IndexedDB)에 설명되어 있으며, 이벤트 베이스다.

또한 [https://github.com/jakearchibald/idb](https://github.com/jakearchibald/idb)같은 프로미스-베이스 래퍼의 도움을 받아 `async/await`을 쓸 수도 있다. 이건 꽤나 편리하지만 래퍼가 완벽한 것은 아니기에 모든 경우의 이벤트를 대체할 수는 없다. 그러니 우리는 이벤트로 시작할 것이고 이후에 IndexedDb를 이해하고 나면 래퍼를 쓸 것이다.

## Open database

IndexedDB로 작업을 시작하기 위해, 먼저 데이터 베이스를 `open` (연결) 해야한다.

문법:

```js
let openRequest = indexedDB.open(name, version);
```

- `name` – 문자열, 데이터베이스 이름.
- `version` – 양수 버전, by default `1` (explained below).

다른 이름을 가진 많은 데이터베이스를 가질 수 있지만, 그것들 전부 현재 출처(domain/protocol/port) 안에 존재한다. 다른 웹사이트들은 서로의 데이터베이스에 접근할 수 없다.

호출은 `openRequest` 객체를 반환하고 그것에 있는 이벤트를 들어야 한다:

- `success`: 데이터베이스가 준비됨, `openRequest.result`안에 우리가 이후 이어질 더 많은 호출을 위해 써야하는 “데이터베이스 객체”가 있다.
- `error`: 오프닝 실패.
- `upgradeneeded`: 데이터베이스가 준비됨, 하지만 버전이 낡았음(see below).

**IndexedDB는 서버사이드 데이터베이스에 없는 “schema versioning(스키마 버전 관리)”의 빌트-인 메커니즘을 가진다.**

서버사이드 데이터베이스와는 다르게, IndexedDB는 클라이언트사이드로, 데이터가 브라우저에 저장된다. 그래서 우리 개발자들은 그것에 풀타임 접근권한이 없다. 그래서 우리가 새로운 버전의 앱을 퍼블리싱할 때, 유저가 우리 웹페이지를 방문하면 우리는 데이터베이스를 업데이트 해야할 수 있다.

만약 로컬 데이터베이스 버전이 `open`에 명시된 것보다 낮다면, 특별한 이벤트 `upgradeneeded`가 트리거되고 우리는 버전을 비교해 필요하다면 데이터 구조를 업그레이드할 수 있다.

`upgradeneeded` 이벤트는 데이터베이스가 아직 존재하지 않을 때(엄밀히 따지자면, 버전 `0`)에도 트리거한다. 그래서 초기화를 수행할 수 있다.

우리 앱의 첫 버전을 출시했다고 해보자.

우리는 버전 `1`로 데이터베이스를 열 수 있고 `upgradeneeded` 핸들러에서 이렇게 초기화를 수행할 수 있다:

```js
let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {
  // triggers if the client had no database
  // ...perform initialization...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // continue working with database using db object
};
```

이후, 우리는 두번째 버전을 출시한다.

우리는 버전 `2`로 열어서 이렇게 업그레이드를 수행할 수 있다:

```js
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function(event) {
  // the existing database version is less than 2 (or it doesn't exist)
  let db = openRequest.result;
  switch(event.oldVersion) { // existing db version
    case 0:
      // version 0 means that the client had no database
      // perform initialization
    case 1:
      // client had version 1
      // update
  }
};
```

알아두자: 우리의 현재 버전은 `2`이기 때문에, `onupgradeneeded` 핸들러는 처음으로 접근해서 데이터 베이스가 없는 유저에게 적합하고, 또한 업그레이드를 위한 버전 `1`을 위해 버전 `0`의 코드 브랜치를 가진다.

그리고 나서 오직 `onupgradeneeded` 핸들러가 에러없이 끝날 때만 `openRequest.onsuccess`가 트리거하고 데이터베이스는 성공적으로 열렸다고 간주된다.

데이터베이스 삭제를 위해서는:

```js
let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror tracks the result
```

>**데이터베이스의 오래된 버전은 열 수 없다.**
>
>만약 현재 유저 데이터베이스가 `open` 호출에 있는 것보다 높은 버전이라면, 예를 들어 현존 DB 버전이 `3`이고 우리는 `open(...2)`를 하려고 하면, 에러가 발생하고 `openRequest.onerror`가 트리거된다.
>
>이런 일은 드물지만, 방문자가 예를 들면 프록시 캐시로부터 낡은 자바스크립트 코드를 로드하려고 할 때, 발생할 수 있다. 그래서 코드는 오래됐지만 그 데이터베이스는 새 것이다.
>
>에러로부터 보호하려면, `db.version`을 확인하고 페이지 새로고침을 제안해야 한다. 이런 문제를 절대 겪지 않도록 오래된 코드를 로딩하는 것을 피하기 위해 적절한 HTTP 캐싱 헤더를 쓰자.

### Parallel update problem

versioning에 관해 얘기한 김에, 연관된 작은 문제를 보자.

자, 이렇다:

1. 방문자는 데이터베이스 버전 `1`로 우리 사이트를 브라우저 탭에서 연다.
2. 그 후 우리는 업데이트를 해서 코드가 더 새 것이다.
3. 그리고 나서 같은 방문자가 우리 사이트를 다른 탭에서 연다.

DB 버전 `1`에 연결된 탭 하나가 있다, 두번째 탭은 그것을 두번째 탭의 `upgradeneeded` 핸들러 안에서 버전 `2`로 업그레이드하려는 시도를 한다.

문제는 두 탭이 같은 사이트, 같은 출처이기 때문에 데이터베이스가 그 사이에 공유되고 있다는 것이다. 그리고 데이터베이스는 버전 `1`과 `2` 중 하나만 될 수 있다. 버전 `2`로 업데이트를 수행하려면, 첫 번째 탭을 포함한 버전 1로의 모든 연결이 반드시 닫혀야 한다.

그걸 정리하기 위해서, `versionchange` 이벤트가 “outdated(낡은)” 데이터베이스 객체에서 트리거한다. 우리는 그 이벤트를 듣고 낡은 데이터베이스 연결을 끊어야 한다(그리고 업데이트된 코드를 불러오기 위해 페이지 새로고침을 제안해야 할 것이다).

만약 우리가 `versionchange` 이벤트를 듣지 않고 오래된 연결을 닫지 않으면, 두번째의 새 연결이 만들어지지 않을 것이다. `openRequest` 객체는 `success` 대신에 `blocked` 이벤트를 발생시킬 것이다. 그러므로 두번째 탭은 작동하지 않을 것이다.

여기 병렬 업그레이드를 올바르게 다루기 위한 코드다.

이 코드는 오래된 연결을 닫는`onversionchange` 핸들러를 데이터베이스가 열린 뒤에 설치한다.

```js
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  db.onversionchange = function() {
    db.close();
    alert("Database is outdated, please reload the page.")
  };

  // ...the db is ready, use it...
};

openRequest.onblocked = function() {
  // this event shouldn't trigger if we handle onversionchange correctly

  // it means that there's another open connection to same database
  // and it wasn't closed after db.onversionchange triggered for them
};
```

여기서 우리는 두 가지 일을 한다:

1. 병렬 업데이트 시도에 관해 알리기 위해서, 성공적인 오프닝 이후 `db.onversionchange` 리스너를 추가한다.
2. 오래된 연결이 닫히지 않았을 때를 다루기 위해 `openRequest.onblocked` 리스너를 추가한다. 이것은 우리가 `db.onversionchange`안에서 연결을 닫으면 발생하지 않는다.

다른 변형도 있다. 예를 들어, `db.onversionchange`에서 작업을 정상적으로 종료하고, 연결이 닫히기 전에 방문자에게 데이터를 저장하라는 메시지를 띄울 수 있다. 새로운 업데이트 연결은 `db.onversionchange`가 완료되지 않은 상태에서 즉시 막힐 것이고 새 탭의 방문자에게 업데이트를 위해 다른 탭을 닫으라고 요청할 수 있다.

이러한 업데이트 충돌은 드물게 발생하지만, 스크립트가 조용히 죽어가면서 유저를 놀래키지 않도록, `onblocked` 핸들러같은 것으로 다루는 방법을 알아야 한다.

