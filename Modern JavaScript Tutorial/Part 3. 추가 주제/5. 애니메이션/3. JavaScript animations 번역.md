# JavaScript animations

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

자바스크립트 애니메이션은 CSS가 할 수 없는 것들을 다루게 해준다.

예시로, 베지어 곡선과는 다른 타이밍 함수와 함께 복잡한 패스를 따라 움직이는것이나, 캔버스 위 애니메이션이 있다.

## Using setInterval

애니메이션은 보통 HTML/CSS 프로퍼티를 약간 변경하는 프레임의 시퀀스로 구현될 수 있다. 

예를 들어,  `0px`부터 `100px`로 `style.left`를 변경하는 것은 요소를 움직인다. 그리고 만약 그것을 초당 50번같은 아주 미세한 딜레이를 가지고 `2px`만큼 변경하면서 `setInterval`에서 증가시키면, 매끄럽게 보일 것이다. 이 원리는 영화와 똑같다: 초당 24 프레임은 매끄럽게 보이기 충분하다.

슈도 코드는 이것과 같다:

```js
let timer = setInterval(function() {
  if (animation complete) clearInterval(timer);
  else increase style.left by 2px
}, 20); // change by 2px every 20ms, about 50 frames per second
```

 애니메이션의 좀 더 복잡한 예시:
```js
let start = Date.now(); // remember start time

let timer = setInterval(function() {
  // how much time passed from the start?
  let timePassed = Date.now() - start;

  if (timePassed >= 2000) {
    clearInterval(timer); // finish the animation after 2 seconds
    return;
  }

  // draw the animation at the moment timePassed
  draw(timePassed);

}, 20);

// as timePassed goes from 0 to 2000
// left gets values from 0px to 400px
function draw(timePassed) {
  train.style.left = timePassed / 5 + 'px';
}
```

데모를 클릭하자:

```html
<!DOCTYPE HTML>
<html>

<head>
  <style>
    #train {
      position: relative;
      cursor: pointer;
    }
  </style>
</head>

<body>

  <img id="train" src="https://js.cx/clipart/train.gif">


  <script>
    train.onclick = function() {
      let start = Date.now();

      let timer = setInterval(function() {
        let timePassed = Date.now() - start;

        train.style.left = timePassed / 5 + 'px';

        if (timePassed > 2000) clearInterval(timer);

      }, 20);
    }
  </script>


</body>

</html>
```

## Using requestAnimationFrame

우리가 동시에 동작하는 여러 애니메이션을 가지고 있다고 상상해보자.

우리가 그것들을 각각 작동하면, 각각의 것이 `setInterval(..., 20)`를 가졌어도, 브라우저는 매 `20ms`보다 훨씬 자주 리페인팅해야 한다.

이것은 시작 시간이 서로 다르기 때문에, “매 20ms”는 각 애니메이션마다 다르게 된다. 인터벌은 정렬되지 않는다. 그래서 우리는 `20ms`이내에 여러개의 독립적인 작동을 가지게 된다.

즉, 이것은:

```js
setInterval(function() {
  animate1();
  animate2();
  animate3();
}, 20)
```

3개의 독립적인 호출보다 가볍다:

```js
setInterval(animate1, 20); // independent animations
setInterval(animate2, 20); // in different places of the script
setInterval(animate3, 20);
```

브라우저가 쉽게 다시 그릴수 있게 하기 위해, 그리고 따라서 CPU 부하를 줄이고 더 매끄럽게 보이게 하도록 이러한 독립적인 리드로우(다시 그리기)는 함께 그룹지어져야 한다.

하나 더 명심할 것이 있다. 가끔 CPU가 과부하되거나 덜 자주 리드로우할 이유가 있을때(브라우저 탭이 숨겨져있을 때와 같이), 우리는 정말로 매 `20ms`마다 작동해서는 안된다.

하지만 자바스크립트에서 그것에 관해 어떻게 알 수 있을까? 함수 `requestAnimationFrame`를 제공하는 명세서 [Animation timing](http://www.w3.org/TR/animation-timing/) 가 있다. 이것은 이 모든 문제와 더 많은 문제를 해결한다.

문법:

```js
let requestId = requestAnimationFrame(callback)
```

브라우저가 애니메이션을 하고 싶을 때, `callback` 함수가 가장 가까운 시간에 작동하도록 스케줄한다.

만약 우리가 `callback` 안의 요소를 변경하면, CSS 애니메이션과 다른 `requestAnimationFrame` 콜백과 함께 그룹지어질 것이다. 따라서 많은 지오메트리(기하) 대신 하나의 지오메트리 재계산 및 리페인트가 있을 것이다.

반환된 값 `requestId`는 호출을 취소하기 위해 쓰일 수 있다:

```js
// cancel the scheduled execution of callback
cancelAnimationFrame(requestId);
```

`callback`은 마이크로초로 페이지 불러오기의 시작으로부터 전달된 시간을 하나의 인자로 얻는다.이 시간은 [performance.now()](https://developer.mozilla.org/ko/docs/Web/API/Performance/now)를 호출함으로서 얻을 수도 있다.

CPU가 과부화되거나 노트북 배터리가 거의 방전되거나 다른 이유가 있는게 아니라면, 대개 `callback`은 아주 금방 작동한다.

아래의 코드는 `requestAnimationFrame`을 위한 처음 10번의 동작 사이의 시간을 보여준다. 보통 10-20ms다:

```html
<script>
  let prev = performance.now();
  let times = 0;

  requestAnimationFrame(function measure(time) {
    document.body.insertAdjacentHTML("beforeEnd", Math.floor(time - prev) + " ");
    prev = time;

    if (times++ < 10) requestAnimationFrame(measure);
  })
</script>
```

## Structured animation

이제 `requestAnimationFrame`를 기반으로 한 더 보편적인 애니메이션 함수를 만들 수 있다:

```js
function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction goes from 0 to 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // calculate the current animation state
    let progress = timing(timeFraction)

    draw(progress); // draw it

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
```

함수 `animate`는 애니메이션을 필수적으로 묘사하는 3개의 파라미터를 허용한다:

**`duration`**

전체 애니메이션 시간. 예: `1000`.

**`timing(timeFraction)`**

타이밍 함수. 예: 흘러간 시간(`0`에서 시작, `1`에서 끝남)의 조각을 얻고 애니메이션 완료(베지어 곡선에서 `y`같은)를 반환하는 CSS-property `transition-timing-function`.

예를 들어, 직선 함수는 애니메이션이 같은 속도로 균일하게 간다는 것을 의미한다:

```js
function linear(timeFraction) {
  return timeFraction;
}
```

그래프:

<img src="https://ko.javascript.info/article/js-animation/linear.svg" alt="" width="234" height="240">

이것은 `transition-timing-function: linear`와 같다. 아래에 더 흥미로운 변수가 있다.

**`draw(progress)`**

애니메이션 완료 상태를 취하고 그리는 함수다. 값 `progress=0`은 시작 애니메이션 상태를 나타내고, `progress=1`은 끝 상태를 나타낸다.

이것은 실제로 애니메이션을 그려내는 함수다.

이건 요소를 움직일 수 있다:

```js
function draw(progress) {
  train.style.left = progress + 'px';
}
```

…혹은 다른 뭐든지, 어떤 방식으로도 animate할 수 있다.

우리 함수를 써서 `0`부터 `100%`로 요소 `width`를 animate하자.

데모의 요소를 클릭하자:

animate.js:

```js
function animate({duration, draw, timing}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    let progress = timing(timeFraction)

    draw(progress);

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
```

index.html:

```html
<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <style>
    progress {
      width: 5%;
    }
  </style>
  <script src="animate.js"></script>
</head>

<body>


  <progress id="elem"></progress>

  <script>
    elem.onclick = function() {
      animate({
        duration: 1000,
        timing: function(timeFraction) {
          return timeFraction;
        },
        draw: function(progress) {
          elem.style.width = progress * 100 + '%';
        }
      });
    };
  </script>


</body>

</html>
```

그걸 위한 코드:

```js
animate({
  duration: 1000,
  timing(timeFraction) {
    return timeFraction;
  },
  draw(progress) {
    elem.style.width = progress * 100 + '%';
  }
});
```

CSS 애니메이션과는 다르게, 우리는 여기서 어떤 타이밍 함수와 그리기 함수라도 만들 수 있다. 타이밍 함수는 베지어 곡선에 제한되지 않는다. 그리고 `draw`는 프로퍼티를 넘어갈 수 있고, 불꽃놀이 애니메이션 등을 위한 새로운 요소를 생성할 수 있다.

## Timing functions

우리는 가장 간단한 직선 타이밍 함수를 살펴봤다.

그것들을 좀 더 봐보자. 그들이 어떻게 움직이는 지 보기 위해 다양한 타이밍 함수를 가진 이동 애니메이션을 시도할 것이다.
### Power of n

만약 애니메이션 속도를 올리고 싶다면, 우리는 n 제곱의 `progress`를 쓸 수 있다.

예를 들어, 포물선과 같은:

```js
function quad(timeFraction) {
  return Math.pow(timeFraction, 2)
}
```

The graph:

<img src="https://ko.javascript.info/article/js-animation/quad.svg" alt="" width="234" height="240">

…혹은 큐빅 곡선이나 `n`보다 큰 이벤트다. 제곱을 증가시키면 속도는 더 빨라진다.

5승의 `progress` 그래프다:

<img src="https://ko.javascript.info/article/js-animation/quint.svg" alt="" width="234" height="240">

### The arc

Function:

```js
function circ(timeFraction) {
  return 1 - Math.sin(Math.acos(timeFraction));
}
```

The graph:

<img src="https://ko.javascript.info/article/js-animation/circ.svg" alt="" width="234" height="240">

### Back: bow shooting

이 함수는 “bow shooting”을 한다. 먼저, 우리는 “pull the bowstring(시위를 당기고)”, “shoot(쏜다)”.

이전의 함수와 다르게, 이것은 “elasticity coefficient(유연한 계수)”인 추가적인 파라미터 `x`에 의존한다. “bowstring pulling”의 거리는 이것에 으해 결정된다.

The code:

```js
function back(x, timeFraction) {
  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)
}
```

**The graph for `x = 1.5`:**

<img src="https://ko.javascript.info/article/js-animation/back.svg" alt="" width="234" height="240">

애니메이션의 경우 우리는 `x`의 특정한 값을 사용한다. 예를 들면 `x = 1.5`.

### Bounce

우리가 공을 떨어트린다고 상상해보자. 떨어지고나서 몇 번 다시 튀어오르다가 멈춘다.

`bounce` 함수는 똑같은 일을 반대 순서로 한다: “bouncing”이 즉시 시작된다. 이를 위해 몇몇 특별한 계수가 사용된다:

```js
function bounce(timeFraction) {
  for (let a = 0, b = 1, result; 1; a += b, b /= 2) {
    if (timeFraction >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
    }
  }
}
```

### Elastic animation

“initial range”를 위해 추가적인 파라미터 `x`를 받아들이는 “elastic” 함수 하나 더.

```js
function elastic(x, timeFraction) {
  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)
}
```

**The graph for `x=1.5`:**
<img src="https://ko.javascript.info/article/js-animation/elastic.svg" alt="" width="233" height="388">
