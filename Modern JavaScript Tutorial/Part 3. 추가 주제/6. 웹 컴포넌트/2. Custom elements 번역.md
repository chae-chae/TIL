# Custom elements

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

자체적인 메서드와 프로퍼티, 이벤트 등을 사용하여 우리 클래스에 의해 묘사되는 커스텀 HTML 요소를 만들 수 있다.

한번 커스텀 요소가 정의되면, 내장된 HTML 요소와 동등하게 사용할 수 있다.

이것은 풍부한 HTML dictionary로서 좋으나, 무한하지는 않다. `<easy-tabs>`, `<sliding-carousel>`, `<beautiful-upload>` 등은 없다. 그냥 우리가 필요한 다른 태그를 생각해보자.

우리는 그것들을 특별한 클래스로 정의할 수 있고 항상 그것들이 HTML의 한 부분인 것처럼 사용할 수 있다.

커스텀 요소는 두 종류가 있다:

1. **Autonomous custom elements(자동 커스텀 요소)** – 추상 `HTMLElement` 클래스를 확장하는 “all-new” 요소.
2. **Customized built-in elements(커스텀된 내장 요소)** – `HTMLButtonElement` 등을 기반으로 커스텀 버튼과 같은 내장 요소를 확장함.

먼저 우리는 자동 커스텀 요소를 다루고, 그 후 커스텀된 내장 요소를 다룰 것이다.

커스텀 요소를 생성하기 위해, 우리는 브라우저에게 그것에 관한 여러 세부사항을 알려줘야 한다: 어떻게 보여줄 것인지, 요소가 페이지에 추가되거나 제거될 때 무슨 일을 하는 지 등등.

이것은 특별한 메서드로 클래스를 만듦으로서 이뤄진다. 이것은 메서드가 얼마 없고, 모든 것이 옵션이기 때문에 쉽다.

전체 목록이 있는 스케치다:

```js
class MyElement extends HTMLElement {
  constructor() {
    super();
    // element created
  }

  connectedCallback() {
    // browser calls this method when the element is added to the document
    // (can be called many times if an element is repeatedly added/removed)
  }

  disconnectedCallback() {
    // browser calls this method when the element is removed from the document
    // (can be called many times if an element is repeatedly added/removed)
  }

  static get observedAttributes() {
    return [/* array of attribute names to monitor for changes */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // called when one of attributes listed above is modified
  }

  adoptedCallback() {
    // called when the element is moved to a new document
    // (happens in document.adoptNode, very rarely used)
  }

  // there can be other element methods and properties
}
```

그 후, 우리는 요소를 등록해야 한다:

```js
// let the browser know that <my-element> is served by our new class
customElements.define("my-element", MyElement);
```

이제부터 태그 `<my-element>`가 있는 어떤 HTML 요소라도, `MyElement`의 인스턴스가 생성되고, 앞서 말한 메서드가 호출된다. 자바스크립트에서 `document.createElement('my-element')` 또한 할 수 있다.

>**커스텀 요소 이름은 반드시 하이픈 `-`을 포함해야 한다.**
>
>커스텀 요소 이름은 반드시 하이픈 `-`을 가져야 한다. `my-element`와 `super-button`은 유효한 이름이지만, `myelement`는 아니다.
>
>이것은 내장 요소와 커스텀 HTML 요소간의 이름 충돌이 없도록 보장하기 위해서이다.

## Example: “time-formatted”

예를 들어, HTML에는 날짜/시간을 위한 `<time>` 요소가 이미 존재한다. 하지만 스스로 포매팅하지는 않는다.

시간을 보기좋은 언어 인식 형태로 표시하는 `<time-formatted>` 요소를 만들어 보자:

```js
<script>
class TimeFormatted extends HTMLElement { // (1)

  connectedCallback() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

}

customElements.define("time-formatted", TimeFormatted); // (2)
</script>

<!-- (3) -->
<time-formatted datetime="2019-12-01"
  year="numeric" month="long" day="numeric"
  hour="numeric" minute="numeric" second="numeric"
  time-zone-name="short"
></time-formatted>
```

1. 클래스는 오직 하나의 메서드 `connectedCallback()`를 가진다 – 브라우저는 `<time-formatted>` 요소가 페이지에 추가됐을 때(또는 HTML parser가 그것을 탐지했을 때) 위의 메서드를 호출하고, 이 메서드는 멋지게 형식화된 시간을 보여주기 위해 브라우저별로 잘 지원되는 내장 [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) 데이터 포매터를 사용한다.
2. `customElements.define(tag, class)`를 통해 우리의 새로운 요소를 등록해야 한다.
3. 그리고 이제 우리는 어디서나 그걸 쓸 수 있다.

>**커스텀 요소 업그레이드**
>
>만약 브라우저가 `customElements.define` 전에 그 어떤 `<time-formatted>` 요소를 마주치면, 에러가 아니다. 하지만 그 요소는 아직 알 수 없는 비정규 태그와 같다.
>
>그런 “정의되지 않은” 요소는 CSS 선택자 `:not(:defined)`를 통해 스타일될 수 있다.
>
>`customElement.define`이 호출될 때, 그들은  “업그레이드“된다: 새로운 `TimeFormatted` 인스턴스가 각각 생성되고, `connectedCallback`가 호출된다. 그들은 `:defined`이 된다.
>
>커스텀 요소에 관한 정보를 얻기 위한 메서드:
>- `customElements.get(name)` – 주어진 `name`으로 커스텀 요소를 위한 클래스를 반환함.
>- `customElements.whenDefined(name)` – 주어진 `name`의 커스텀 요소가 defined 됐을 때, (값 없이) resolve하는 프로미스를 반환함.

>**Rendering in `connectedCallback`, not in `constructor`**
>
>위의 예시에서, 요소 내용은 `connectedCallback` 안에서 렌더(생성)된다.
>
>왜 `constructor`안에서가 아닐까?
>
>이유는 간단하다: `constructor`가 호출될 때, 아직 너무 이르기 때문이다. 요소는 생성됐지만 브라우저는 아직 이 단계에서 속성을 프로세스/할당하지 않았다: `getAttribute` 호출은 `null`을 반환할 것이다. 그러므로 우리는 거기서 렌더할 수 없다.
>
>게다가, 진짜 필요할 때까지 작업을 딜레이하는 더 나은 퍼포먼스 측면이 있다고 생각해보자.
>
>`connectedCallback`은 요소가 문서에 추가될 때 트리거한다. 자식으로써 다른 요소에 추가될 뿐 아니라, 실제로 페이지의 한 부분이 된다. 그래서 우리는 떨어져있는 DOM을 빌드할 수 있고, 요소를 생성하고 이후 사용을 위해 준비할 수 있다. 그들은 페이지에 그들이 만들어졌을 때만 실제로 렌더될 것이다.