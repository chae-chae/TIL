# Quantifiers +, *, ? and {n}

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

`+7(903)-123-45-67`같은 문자열이 있고 그 안의 모든 숫자를 찾고 싶다고 해보자. 하지만 전과는 다르게, 단일 숫자에는 관심이 없고 전체 숫자에만 관심있다: `7, 903, 123, 45, 67`.

숫숫자는 하나 혹은 그 이상의 숫자 `\d`의 시퀀스다. 얼마나 필요한 지 표시하기 위해, *quantifier*를 더할 수 있다.

## Quantity {n}

가장 간단한 퀀티파이어는 중괄호 안의 숫자다: `{n}`.

퀀티파이어는 문자(혹은 문자 클래스, 또는 `[...]` set)에 더해지고 우리가 얼마나 필요한 지 명시한다.

몇 개의 고급 형태가 있다. 예시를 보자:

**The exact count: `{5}`**

`\d{5}`는 정확히 다섯개의 숫자를 나타낸다. `\d\d\d\d\d`와 같다.

아래 예시는 다섯개의 숫자를 찾는다:

```js
alert( "I'm 12345 years old".match(/\d{5}/) ); //  "12345"
```

더 긴 숫자를 제외하기 위해 `\b`를 추가할 수 있다: `\b\d{5}\b`.

**The range: `{3,5}`, match 3-5 times**

3개에서 5개의 숫자를 찾기 위해 중괄호 안에 제한을 둘 수 있다: `\d{3,5}`

```js
alert( "I'm not 12, but 1234 years old".match(/\d{3,5}/) ); // "1234"
```

상한은 생략 가능하다.

정규 표현식 `\d{3,}`는 길이 `3` 이상의 숫자 시퀀스를 찾는다:

```js
alert( "I'm not 12, but 345678 years old".match(/\d{3,}/) ); // "345678"
```

문자열 `+7(903)-123-45-67`로 돌아가보자.

숫자는 연속된 하나 이상의 숫자의 시퀀스다. 따라서 정규 표현식은 `\d{1,}`다:

```js
let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
```

## Shorthands

가장 많이 쓰이는 퀀티파이어의 줄임말이 있다:

**`+`**

“하나 이상”을 의미, `{1,}`와 같음.

예를 들어, `\d+`는 숫자들을 찾는다:

```js
let str = "+7(903)-123-45-67";

alert( str.match(/\d+/g) ); // 7,903,123,45,67
```

**`?`**

“0개 또는 하나”을 의미, `{0,1}`와 같음. 즉, 심볼을 옵션으로 만듦.

예를 들어, 패턴 `ou?r`는 `o`뒤에 0개나 하나의 `u`, 그 후의 `r`을 찾는다.

그러므로, `colou?r`는 `color`와 `colour` 모두 찾는다:

```js
let str = "Should I write color or colour?";

alert( str.match(/colou?r/g) ); // color, colour
```

**`*`**

“0개 이상”을 의미, `{0,}`과 같음. 즉, 문자가 몇 번 반복되거나 없을 수 있음.

예로, `\d0*`는 숫자 뒤에 0(여러개거나 아예 없을 수도 있음)이 따라오는 것을 찾음:

```js
alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
```

`+`(1개 이상)와 비교해보자:

```js
alert( "100 10 1".match(/\d0+/g) ); // 100, 10
// 1 not matched, as 0+ requires at least one zero
```

## More examples

퀀티파이어는 매우 자주 쓰인다. 그들은 복잡한 정규 표현식의 메인 “building block”을 돕는다. 더 많은 예제를 보자.

**십진수(소수점이 있는 숫자)에 관한 정규 표현식: `\d+\.\d+`**

In action:

```js
alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
```

**`<span>`이나 `<p>`와 같이 “속성없는 HTML-tag를 여는 것”에 관한 정규 표현식.**

1. The simplest one: `/<[a-z]+>/i`
    
    ```js
    alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>
	```
    
    정규 표현식은 문자 `<` 다음에 하나 이상의 라틴 문자를 찾고 그 다음에 `>`를 찾는다.
    
2. Improved: `/<[a-z][a-z0-9]*>/i`
    
    표준에 따르면, HTML tag 이름은 첫번째 자리를 제외하고 어느 자리든 숫자를 가질 수 있다. `<h1>`처럼 말이다.
    
    ```js
    alert( "<h1>Hi!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
	```

**“속성없는 HTML-tag를 여닫는 것”에 관한 정규 표현식: `/<\/?[a-z][a-z0-9]*>/i`**

옵셔널 슬래쉬 `/?`를 패턴 시작부분에 추가했다. 백슬래쉬로 이스케이프 해야 한다. 그렇지 않으면 자바스크립트는 그것이 패턴 끝이라고 생각할 것이다.

```js
alert( "<h1>Hi!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
```

>**정규 표현식을 더 정확하게 만들려면 종종 더 복잡하게 만들어야 한다**
>
>이러한 예시들에서 공통적인 규칙을 발견할 수 있다: 정규 표현식이 더 정확할수록, 더 길고 복잡하다.
>
>예를 들어, HTML 태그의 경우 더 간단한 정규 표현식을 쓸 수 있었다: `<\w+>`. 하지만 HTML의 태그 이름에 더 강한 규제가 있을수록, `<[a-z][a-z0-9]*>`이 더 믿을만하다.
>
>`<\w+>`를 써도 될까, 아니면 `<[a-z][a-z0-9]*>`이 필요할까?
>
>실생활에서는 두 변수 모두 용인된다. 우리가 “추가적인“ 일치를 얼마나 더 허용할 수 있는지, 그리고 다른 방법으로 결과에서 일치사항을 제거하는 게 어려운지 아닌지에 달려있다.