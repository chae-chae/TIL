# Greedy and lazy quantifiers

>**주의: 미번역 문서**
>
>한국어로 번역되지 않은 문서라 직접 번역했다. 의역/오역이 있을 수 있다.
>
>원문과 비교하여 읽도록 하자. 
>– @chae-chae

퀀티파이어는 처음 봤을 때는 아주 심플하지만, 사실은 아주 까다롭다.

`/\d+/`보다 더 복잡한 뭔가를 찾고 싶다면 검색이 얼마나 잘 이뤄지는 지 이해해야 한다.

아래 예제를 보자.

텍스트가 있고 모든 인용구 `"..."`를 guillemet marks  `«...»`로 대체한다. 이 마크는 많은 나라에서 타이포그래피로 선호된다.

예를 들어: `"Hello, world"`는 `«Hello, world»`가 되어야 한다. `„Witam, świat!”` (Polish) or `「你好，世界」` (Chinese)같은 다른 인용문도 존재하지만, 우리 과제에서는 `«...»`를 고르자.

제일 먼저 해야할 일은 인용 문자열을 위치시키고 대체하는 것이다.

`/".+"/g`(a quote, then something, then the other quote)같은 정규 표현식은 좋아 보이지만, 그렇지 않다!

Let’s try it:

```js
let regexp = /".+"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(regexp) ); // "witch" and her "broom"
```

…의도한 대로 작동하지 않는단 걸 볼 수 있다.

두 일치 `"witch"`와 `"broom"`을 찾는 대신, 하나를 찾는다: `"witch" and her "broom"`.

그것은 “greediness is the cause of all evil(탐욕은 모든 악의 근원이다)”라고 묘사될 수 있다.

## Greedy search

일치를 찾기 위해, 정규 표현식 엔진은 아래 알고리즘을 사용한다:

- 문자열의 모든 위치에 관해
    - 그 위치의 패턴과 일치하는지 확인.
    - 일치하지 않으면 다음 위치로 움직임.

이러한 공통 규칙은 왜 정규 표현식이 실패하는 지 명확하게 보여주지 않는다. 그러니 패턴 `".+"`에 관해 어떻게 검색이 동작하는 지 자세히 설명하겠다.

1. 처음 패턴 문자는 인용구 `"`다.
    
    정규 표현식 엔진은 소스 문자열 `a "witch" and her "broom" is one` 의 0 포지션에서 `"`를 찾으려고 한다. 하지만 거기엔 `a`가 있으므로, 그 즉시 매치는 없다.
    
    그러고 나서 더 나아간다: 소스 문자열의 다음 위치로 가고 거기서 패턴의 첫 문자를 찾으려고 한다. 다시 실패하고 결국 세번째 위치에서 인용을 찾는다:
    
    <img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy1.svg" alt="" width="463" height="130">
2. 인용구가 감지됐고 엔진은 남은 패턴을 일치하려고 할 것이다. 엔진은 남은 문자열이 `.+"`를 따르는 지 확인한다.
	
	이 경우 다음 패턴 문자는 `.` (a dot)이다. 이것은 “개행을 제외한 어떠한 문자”를 의미하므로, 다음 문자열 글자 `'w'`는 적합하다:
	
	<img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy2.svg" alt="" width="463" height="130">

3. 퀀티파이어 `.+` 때문에 점이 반복된다. 정규 표현식 엔진은 차례로 하나의 문자를 매치에 추가한다.
    
    …언제까지? 모든 문자들이 점과 일치하므로 문자열의 끝에 도달할 때에 멈춘다:
    
    <img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy3.svg" alt="" width="463" height="130">
    
4. 이제 엔진이 `.+`를 반복하는 것을 멈췄고 패턴의 다음 글자를 찾으려 한다. 인용 `"`이다. 하지만 문제가 있다: 문자열이 끝났고, 문자가 더 없다!
    
    정규 표현식 엔진은 너무 많은 `.+`을 가진 걸 이해하고 *backtrack*하기 시작한다.
    
    즉, 한 글자씩 퀄리파이어를 위해 매치를 짧게 만든다:
    
    <img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy4.svg" alt="" width="463" height="130">
    
    이제 문자열이 끝나기 전에  `.+`가 끝나고 그 위치로부터 남은 패턴을 매치하려고 한다.
    
    거기에 인용이 있다면, 검색이 끝나지만 마지막 문자는 `'e'`이므로 일치하지 않는다.
    
5. …따라서 엔진은 `.+`의 반복 수를 한 글자 더 줄인다:
    
    <img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy5.svg" alt="" width="463" height="130">
    
    인용 `'"'`은 `'n'`과 매치하지 않는다.
    
6. 엔진은 계속 백트래킹한다: 패턴이 남아있을 때까지(우리 경우에는 `'"'`) `'.'`의 반복 수를 줄인다:
    
    <img src="https://ko.javascript.info/article/regexp-greedy-and-lazy/witch_greedy6.svg" alt="" width="463" height="130">
    
7. 일치가 완료했다.
    
8. 그러므로 첫 번째 매치는 `"witch" and her "broom"`이다. 정규 표현식이 플래그 `g`를 가진다면, 검색은 첫번째 매치가 끝나는 곳에서 계속 될 것이다. 남은 문자열 `is one`에 인용구가 더 없으므로, 결과도 더 없다.

우리가 예상한 것과는 다르겠지만, 이게 작동하는 원리다.

**그리디 모드(기본)에서 퀀티파이어는 가능한 한 많은 수로 반복된다.**

정규 표현식 엔진은 `.+`에 있어 최대한 많은 문자를 매치에 추가하고, 남은 패턴이 일치하지 않으면 하나씩 짧게 만든다.

우리는 다른 것도 해보고 싶다. Lazy mode(게으른 모드)가 도움이 되는 상황이다.